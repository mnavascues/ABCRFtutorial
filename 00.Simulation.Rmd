---
#############################################################
#                                                           #
# Click on "Run Document" in RStudio to run this worksheet. #
#                                                           #
#############################################################
title: "Quick Introduction to Simulation"
author: "Miguel de Navascu√©s"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
```

## What is a simulation?

Discuss:

- What is a computer simulation?
- What are the sources of randomness?
- How are random numbers produced in a computer?

## Simulation of a coin toss

Simulate a ten coin tosses ($n=10$) using R function `sample(_____)` and probability of getting head $p$. Use a seed for random number generator so your simulation is reproducible:

```{r simulation_coin_toss, exercise=TRUE}
n <- 10
p <- 0.5
coin_toss <- sample(x=c("H","T"),size=_____, replace=_____, prob=_____)
coin_toss
```

```{r simulation_coin_toss-hint}
n <- 10
p <- 0.5
coin_toss <- sample(x=c("H","T"),size=n, replace=T, prob=c(p,1-p))
coin_toss
```

```{r simulation_coin_toss-solution}
set.seed(123456)
n <- 10
p <- 0.5
coin_toss <- sample(x=c("H","T"),size=n, replace=T, prob=c(p,1-p))
coin_toss
```

Simulate directly the number of heads ($h'$) using `rbinom(_____)`:

```{r simulation_coin_toss_rbinom, exercise=TRUE}
n <- 10
p <- 0.5
num_of_sim = 1
h_prime <- rbinom(n=_____,size=_____,prob=_____)
h_prime
```

```{r simulation_coin_toss_rbinom-solution}
n <- 10
p <- 0.5
num_of_sim = 1
h_prime <- rbinom(n=num_of_sim,size=n,prob=p)
h_prime
```



## Simulation of population genetic data

Simulation via the coalescent. For convenience, we will use the R package `phyclust` that includes a version of coalescent simulator ms in this tutorial. In practice, use of other simulators (msprime, fastsimcoal or the original implementation of ms) is recommended.

```{r eval=TRUE, echo=TRUE}
library("phyclust", quietly=T)
```

Simulate with `ms(_____)` a sample of $n=10$ mitochondrial DNA sequences of $l=10000$bp in a population of size $N=10000$ with mutation rate (per bp) $\mu=10^{-8}$:

```{r coalescent_sim, exercise=TRUE}
n<-10
l<-10000
N<-10000
u<-1e-8
num_of_sim<-1
_____
ms(nsam=_____,nreps=_____,opt=_____)
```

```{r coalescent_sim-hint}
n<-10
l<-10000
N<-10000
u<-1e-8
num_of_sim<-1
theta <- _____
ms(nsam=_____,nreps=_____,opt=paste("-t",theta))
```


```{r coalescent_sim-solution}
n<-10
l<-10000
N<-10000
u<-1e-8
num_of_sim<-1
theta <- 2*N*u*l # note that l*u is an approximation!
ms(nsam=n,nreps=num_of_sim,opt=paste("-t",theta))
```


Lets put this text into a more usable form (i.e. matrix of polymorphisms, etc) using a function distributed with the original software ms:

```{r eval=TRUE, echo=FALSE}
# modified for phyclust output with additional spaces between positions values

#read.ms.output --  a function to read in the output of ms.
#
#  This function reads in the output of the program ms, storing the
#   results in a list of lists.
#
# The function takes a single argument,either a file name or a vector
#  of character strings, one string for each line of the output of ms.
#  The function returns a list with some of the following components: 
#       segsites,  times, positions, gametes, probs, nsam, nreps
#
#  Example usage reading output from a file (assuming an executable ms
#  resides in the current working directory):
#
#  system("./ms 5 4 -s 5 >ms.out")
#  msout <- read.ms.output(file="ms.out")
#
#   In which case, msout$gametes[[1]] is a haplotype array for the
#     first sample, msout$gametes[[2]] is the haplotype array for the
#      second sample, etc.  msout$segsites is a vector of the numbers of
#      segregating sites in the samples.  So, for example, 
#      mean( msout$segsites ) returns the mean number of segregating sites
#      in the set of 4 samples.
# 
#   Another example usage, this time reading output from a vector of 
#     character strings: 
#
#    msout.txt <- system("./ms 5 4 -s 5 -L", intern=TRUE)
#    msout <- read.ms.output(msout.txt)
#
#   In this case, msout$time[,1] is then the vector of tmrca's of 
#    the samples and  msout$time[,2] is the vector of total tree
#    lengths of the samples. 
#
# This function is derived from code first written by Dan Davison.

read.ms.output <- function( txt=NA, file.ms.output=NA ) {
    
    if( !is.na(file.ms.output) ) txt <- scan(file=file.ms.output,
       what=character(0), sep="\n", quiet=TRUE)
    if( is.na(txt[1]) ){
    	print("Usage: read.ms.output(txt), or read.ms.output(file=filename)")
    	return()
    	}
    nsam <- as.integer( strsplit(txt[1], split=" ")[[1]][2] )
    ndraws <- as.integer( strsplit( txt[1], split=" ")[[1]][3] )

    h <- numeric()
    result <- list()
    gamlist <- list()
    positions <- list()

    marker <- grep("prob",txt)
    probs <- sapply(strsplit(txt[marker], split=":"), function(vec) as.numeric(vec[2]))
    marker <- grep("time",txt)
    times <- sapply(strsplit(txt[marker], split="\t"), function(vec){ as.numeric(vec[2:3])} )

    
    ## THE OUTPUT TEXT FOR EACH DRAW SHOULD CONTAIN THE WORD "segsites"
    marker <- grep("segsites", txt)
    stopifnot(length(marker) == ndraws)

    ## GET NUMBERS OF SEGREGATING SITES IN EACH DRAW
    segsites <- sapply(strsplit(txt[marker], split=" "), function(vec) as.integer(vec[2]) )
    for(draw in seq(along=marker)) {
        if(!(draw %% 100)) cat(draw, " ")
        if(segsites[draw] > 0) {
        	  tpos <- strsplit(txt[marker[draw]+1], split="    ")
        	  positions[[draw]] <- as.numeric( tpos[[1]][ 2:(segsites[draw]+1) ] ) 
            haplotypes <- txt[(marker[draw] + 2):(marker[draw] + 2 + nsam - 1)]
            haplotypes <- strsplit(haplotypes, split="")
            h <- sapply(haplotypes, function(el) c(as.integer(el)))
            ## IF THERE'S 1 SEGREGATING SITE, THIS WON'T BE A MATRIX 
            if(segsites[draw] == 1) h <- as.matrix(h)
            ## OTHERWISE, IT NEEDS TO BE TRANSPOSED
            else h <- t(h)
        }
        else {
        	h <- matrix(nrow=nsam, ncol=0)
        	positions[[draw]]<- NA
        }
		 gamlist[[draw]] <- h
        stopifnot(all(dim(h) == c(nsam, segsites[draw]))) 
    }
	cat("\n")
    list(segsites=segsites, gametes=gamlist, probs=probs, times=t(times), positions=positions, nsam=nsam, nreps=ndraws ) 
}
```

```{r eval=FALSE, echo=TRUE}
source(readms.output.R)
```

Use `read.ms.output(_____)` function to read ms output and print the number of segregating sites only

```{r coalescent_sim_segsites, exercise=TRUE}
n<-10
l<-10000
N<-10000
u<-1e-8
num_of_sim<-1
theta <- 2*N*u*l # note that l*u is an approximation!
msout <- ms(nsam=n,nreps=num_of_sim,opt=paste("-t",theta))
sim_data <- read.ms.output(____)
_____
```

```{r coalescent_sim_segsites-hint}
n<-10
l<-10000
N<-10000
u<-1e-8
num_of_sim<-1
theta <- 2*N*u*l # note that l*u is an approximation!
msout <- ms(nsam=n,nreps=num_of_sim,opt=paste("-t",theta))
sim_data <- read.ms.output(txt=msout)
sim_data$_____
```



```{r coalescent_sim_segsites-solution}
n<-10
l<-10000
N<-10000
u<-1e-8
num_of_sim<-1
theta <- 2*N*u*l # note that l*u is an approximation!
msout <- ms(nsam=n,nreps=num_of_sim,opt=paste("-t",theta))
sim_data <- read.ms.output(txt=msout)
sim_data$segsites
```




